{"version":3,"sources":["../src/index.ts","../src/flow/Flow.tsx","../src/flow/FlowContext.tsx","../src/flow/graphHelpers.ts","../src/flow/flowStateManagers.ts","../src/flow/NodePresenter.tsx","../src/flow/useURLParams.ts","../src/flow/pathParamHelpers.ts","../src/flow/useFlow.ts"],"sourcesContent":["export * from \"./flow\";\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { FlowContext } from \"@/flow/FlowContext\";\nimport { defaultStateManager } from \"@/flow/flowStateManagers\";\nimport {\n\tgetNextPage,\n\tgetNode,\n\tgetPreviousPage,\n\tresolveNextPage,\n\tshouldSkipStep,\n} from \"@/flow/graphHelpers\";\nimport { Presenter } from \"@/flow/NodePresenter\";\nimport type {\n\tComponentLoader,\n\tFlowContextValue,\n\tFlowGraph,\n\tFlowState,\n\tFlowStateByPage,\n\tUrlParamsAdapter,\n} from \"@/flow/types\";\nimport { useUrlParams } from \"@/flow/useURLParams\";\n\n/**\n * Configuration options for the Flow component\n */\nexport type FlowConfig = {\n\t/**\n\t * Optional URL params adapter (defaults to browser query params implementation).\n\t *\n\t * Controls how the flow reads/writes URL parameters (page, id, etc.).\n\t *\n\t * - **Omit (default)**: Uses query params like `?page=pageA&id=xyz`\n\t * - **Path-based URLs**: Pass `createPathParamsAdapter({ template: \"/[id]/page/[page]\" })`\n\t *   to use path segments like `/test123/page/pageA`\n\t * - **Framework adapters**: Use `createPathParamsAdapterFromProps` for Next.js/Remix\n\t *   or create a custom adapter for other routing libraries\n\t *\n\t * @example\n\t * ```ts\n\t * // Query params (default - no adapter needed)\n\t * <Flow graph={graph} /> // URLs: ?page=pageA&id=xyz\n\t *\n\t * // Path-based URLs\n\t * const adapter = createPathParamsAdapter({ template: \"/[id]/page/[page]\" });\n\t * <Flow graph={graph} config={{ urlParamsAdapter: adapter }} />\n\t * // URLs: /test123/page/pageA\n\t * ```\n\t */\n\turlParamsAdapter?: UrlParamsAdapter;\n\n\t/**\n\t * Optional URL parameter name for the current page (defaults to \"page\")\n\t */\n\tpageParamName?: string;\n\n\t/**\n\t * Optional URL parameter name for the flow UUID (defaults to \"id\")\n\t */\n\tuuidParamName?: string;\n\n\t/**\n\t * Optional callback when page changes. Receives the new page, previous page\n\t * (null on initial load), and the accumulated state (merged from all pages).\n\t * Fires on initial load and every navigation.\n\t */\n\tonPageChange?: (\n\t\tpage: string | null,\n\t\tpreviousPage: string | null,\n\t\tstate: FlowStateByPage,\n\t) => void;\n\n\t/**\n\t * Whether to use the internal state system (session storage).\n\t * Default: true. Set to false to use navigation only with no persisted state.\n\t * When false, state is kept in memory only (lost on refresh).\n\t */\n\tenableState?: boolean;\n\n\t/**\n\t * Map of page identifiers to component loaders\n\t * Each loader should return a promise that resolves to a component with a default export\n\t */\n\tcomponentLoaders?: Map<string, ComponentLoader>;\n};\n\n/**\n * Props for the Flow component\n */\nexport type FlowProps = {\n\t/**\n\t * The flow graph definition (nodes + component loaders)\n\t */\n\tgraph: FlowGraph;\n\n\t/**\n\t * Optional configuration object\n\t */\n\tconfig?: FlowConfig;\n};\n\n/**\n * Main Flow component. Orchestrates graph navigation, state management, and URL params.\n */\n/**\n * Generates a UUID and returns the last 5 characters (digits/letters)\n */\nfunction generateShortUuid(): string {\n\t// Generate a UUID and take the last 5 characters\n\t// Remove hyphens first to ensure we get 5 alphanumeric characters\n\tconst uuid = crypto.randomUUID().replace(/-/g, \"\");\n\treturn uuid.slice(-5);\n}\n\nexport function Flow({ graph, config = {} }: FlowProps) {\n\tconst {\n\t\turlParamsAdapter,\n\t\tpageParamName = \"page\",\n\t\tuuidParamName = \"id\",\n\t\tonPageChange,\n\t\tenableState = true,\n\t\tcomponentLoaders,\n\t} = config;\n\n\tconst stateManager = defaultStateManager;\n\n\ttype PageStateEntry = { page: string; state: FlowState };\n\tconst [memoryEntries, setMemoryEntries] = useState<PageStateEntry[]>([]);\n\n\tconst mergeEntries = useCallback((entries: PageStateEntry[]): FlowStateByPage => {\n\t\tconst byPage: FlowStateByPage = {};\n\t\tfor (const e of entries) {\n\t\t\tbyPage[e.page] = { ...e.state };\n\t\t}\n\t\treturn byPage;\n\t}, []);\n\n\t// Build component loaders map from graph if not provided\n\tconst componentLoadersMap = useMemo(() => {\n\t\tif (componentLoaders) {\n\t\t\treturn componentLoaders;\n\t\t}\n\t\t// If not provided, create an empty map (users must provide componentLoaders)\n\t\treturn new Map<string, ComponentLoader>();\n\t}, [componentLoaders]);\n\n\tconst urlParams = useUrlParams(urlParamsAdapter);\n\n\t// Get or generate UUID (last 5 digits)\n\tconst [flowUuid, setFlowUuid] = useState<string>(() => {\n\t\tconst existingUuid = urlParams.getParam(uuidParamName);\n\t\tif (existingUuid) {\n\t\t\treturn existingUuid;\n\t\t}\n\t\tconst newUuid = generateShortUuid();\n\t\t// Set it in URL if it doesn't exist\n\t\tif (typeof window !== \"undefined\") {\n\t\t\turlParams.setParam(uuidParamName, newUuid);\n\t\t}\n\t\treturn newUuid;\n\t});\n\n\t// Sync UUID with URL param\n\tuseEffect(() => {\n\t\tconst urlUuid = urlParams.getParam(uuidParamName);\n\t\tif (urlUuid && urlUuid !== flowUuid) {\n\t\t\tsetFlowUuid(urlUuid);\n\t\t} else if (!urlUuid) {\n\t\t\turlParams.setParam(uuidParamName, flowUuid);\n\t\t}\n\t}, [flowUuid, uuidParamName, urlParams]);\n\n\t// Determine initial page - start with null to ensure validation completes before rendering\n\t// We'll validate in useEffect to ensure session storage is accessible\n\tconst [currentPage, setCurrentPage] = useState<string | null>(null);\n\n\t// Track if we're currently validating initial state (entry point + session storage check)\n\t// This prevents rendering until we've confirmed we're either on entry point or state exists\n\t// Always start with true - we'll validate in the effect\n\tconst [isValidating, setIsValidating] = useState(true);\n\n\t// Track if we're currently checking if a page should be skipped\n\tconst [isCheckingSkip, setIsCheckingSkip] = useState(false);\n\tconst skipCheckRef = useRef(false);\n\tconst hasInitializedRef = useRef(false);\n\n\t// State version counter to trigger re-computation of allState\n\tconst [stateVersion, setStateVersion] = useState(0);\n\n\t// Get accumulated state from all pages\n\tconst allState = useMemo(() => {\n\t\tif (enableState) {\n\t\t\tconst _ = stateVersion;\n\t\t\treturn stateManager.getAllState(graph, flowUuid);\n\t\t}\n\t\treturn mergeEntries(memoryEntries);\n\t}, [\n\t\tenableState,\n\t\tstateVersion,\n\t\tgraph,\n\t\tstateManager,\n\t\tflowUuid,\n\t\tmergeEntries,\n\t\tmemoryEntries,\n\t]);\n\n\t// Early validation check: Ensure we're either on entry point or state exists\n\t// This runs first to prevent any rendering until validation is complete\n\tuseEffect(() => {\n\t\tif (!isValidating) {\n\t\t\treturn; // Validation already complete\n\t\t}\n\n\t\tconst urlPage = urlParams.getParam(pageParamName);\n\t\tconst entryPoint = graph.entryPoint || null;\n\t\tconst isEntryPoint = urlPage === entryPoint;\n\n\t\t// If we're on entry point or no page param, no validation needed (will go to entry point)\n\t\tif (isEntryPoint || !urlPage) {\n\t\t\tconst initialPage = urlPage || entryPoint;\n\t\t\tsetCurrentPage(initialPage);\n\t\t\tsetIsValidating(false);\n\t\t\tonPageChange?.(initialPage, null, allState);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check page existence first: if page doesn't exist, set to not found\n\t\tif (!graph.nodes.has(urlPage)) {\n\t\t\tsetCurrentPage(\"__notfound__\");\n\t\t\tsetIsValidating(false);\n\t\t\tonPageChange?.(\"__notfound__\", null, allState);\n\t\t\treturn;\n\t\t}\n\n\t\t// When state enabled: check if UUID has state in session storage\n\t\tif (enableState) {\n\t\t\tconst uuidExists = stateManager.hasState(flowUuid);\n\t\t\tif (!uuidExists) {\n\t\t\t\tsetCurrentPage(\"__expired__\");\n\t\t\t\tsetIsValidating(false);\n\t\t\t\tonPageChange?.(\"__expired__\", null, allState);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Validation passes\n\t\tsetCurrentPage(urlPage);\n\t\tsetIsValidating(false);\n\t\tonPageChange?.(urlPage, null, allState);\n\t}, [\n\t\tisValidating,\n\t\turlParams,\n\t\tpageParamName,\n\t\tgraph,\n\t\tflowUuid,\n\t\tstateManager,\n\t\tenableState,\n\t\tonPageChange,\n\t\tallState,\n\t]);\n\n\t// Sync current page with URL param changes (browser back/forward)\n\t// URL is the source of truth - when URL changes, it drives what page is shown\n\t// Also validates UUID existence and page validity BEFORE pre-registering state\n\t// Run validation immediately on mount to ensure correct initial state\n\tuseEffect(() => {\n\t\t// Don't proceed if still validating - wait for validation to complete\n\t\tif (isValidating) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst urlPage = urlParams.params[pageParamName] ?? null;\n\t\tconst entryPoint = graph.entryPoint || null;\n\t\tconst isEntryPoint = urlPage === entryPoint;\n\t\tconst uuidExists = enableState ? stateManager.hasState(flowUuid) : false;\n\n\t\t// Check page existence first: unknown page → not found (regardless of UUID state)\n\t\tif (urlPage && !graph.nodes.has(urlPage)) {\n\t\t\tif (currentPage !== \"__notfound__\") {\n\t\t\t\tsetCurrentPage(\"__notfound__\");\n\t\t\t\tonPageChange?.(\"__notfound__\", currentPage, allState);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// When state enabled: page exists but no state for UUID → expired\n\t\tif (enableState && !uuidExists && urlPage && !isEntryPoint) {\n\t\t\tif (currentPage !== \"__expired__\") {\n\t\t\t\tsetCurrentPage(\"__expired__\");\n\t\t\t\tonPageChange?.(\"__expired__\", currentPage, allState);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Validation passes - ensure currentPage matches URL page if it was set to error state initially\n\t\tif (\n\t\t\t(currentPage === \"__expired__\" || currentPage === \"__notfound__\") &&\n\t\t\turlPage &&\n\t\t\tgraph.nodes.has(urlPage)\n\t\t) {\n\t\t\tsetCurrentPage(urlPage);\n\t\t\tonPageChange?.(urlPage, currentPage, allState);\n\t\t}\n\n\t\t// If we're already showing an error page but validation passes, don't proceed\n\t\tif (currentPage === \"__expired__\" || currentPage === \"__notfound__\") {\n\t\t\tif (\n\t\t\t\turlPage &&\n\t\t\t\turlPage !== currentPage &&\n\t\t\t\tgraph.nodes.has(urlPage) &&\n\t\t\t\t(enableState ? uuidExists : true)\n\t\t\t) {\n\t\t\t\tsetCurrentPage(urlPage);\n\t\t\t\tonPageChange?.(urlPage, currentPage, allState);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// When state enabled: pre-register state for new flow starts\n\t\tif (enableState) {\n\t\t\tif (\n\t\t\t\t!hasInitializedRef.current &&\n\t\t\t\t!uuidExists &&\n\t\t\t\t(isEntryPoint || !urlPage)\n\t\t\t) {\n\t\t\t\tstateManager.preRegisterState(graph, flowUuid);\n\t\t\t\thasInitializedRef.current = true;\n\t\t\t\tsetStateVersion((prev) => prev + 1);\n\t\t\t} else if (uuidExists) {\n\t\t\t\thasInitializedRef.current = true;\n\t\t\t}\n\t\t} else {\n\t\t\thasInitializedRef.current = true;\n\t\t}\n\n\t\t// If URL has a page param and it's different from current page\n\t\tif (urlPage && urlPage !== currentPage && graph.nodes.has(urlPage)) {\n\t\t\t// Check if the URL page should be skipped (handles browser back/forward landing on skipped pages)\n\t\t\tif (shouldSkipStep(graph, urlPage, allState)) {\n\t\t\t\t// Determine direction: if urlPage is the previous page from current, we're going back\n\t\t\t\tconst prevFromCurrent = currentPage\n\t\t\t\t\t? getPreviousPage(graph, currentPage, allState)\n\t\t\t\t\t: null;\n\t\t\t\tconst isGoingBack = prevFromCurrent === urlPage;\n\n\t\t\t\t// Get the appropriate non-skipped page based on direction\n\t\t\t\tconst targetPage = isGoingBack\n\t\t\t\t\t? getPreviousPage(graph, urlPage, allState)\n\t\t\t\t\t: getNextPage(graph, urlPage, allState);\n\n\t\t\t\tif (targetPage) {\n\t\t\t\t\t// Replace the skipped page in URL with the appropriate non-skipped page\n\t\t\t\t\turlParams.replaceParam(pageParamName, targetPage);\n\t\t\t\t\tsetCurrentPage(targetPage);\n\t\t\t\t\tonPageChange?.(targetPage, currentPage, allState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Normal navigation - page is not skipped, URL drives the state\n\t\t\t\tsetCurrentPage(urlPage);\n\t\t\t\tonPageChange?.(urlPage, currentPage, allState);\n\t\t\t}\n\t\t} else if (!urlPage) {\n\t\t\t// If URL has no page param, sync to entry point\n\t\t\tif (entryPoint && entryPoint !== currentPage) {\n\t\t\t\tconst previousPage = currentPage;\n\t\t\t\tsetCurrentPage(entryPoint);\n\t\t\t\turlParams.setParam(pageParamName, entryPoint);\n\t\t\t\tonPageChange?.(entryPoint, previousPage, allState);\n\t\t\t} else if (!entryPoint && currentPage) {\n\t\t\t\t// No entry point and no URL param, clear current page\n\t\t\t\tconst previousPage = currentPage;\n\t\t\t\tsetCurrentPage(null);\n\t\t\t\tonPageChange?.(null, previousPage, allState);\n\t\t\t}\n\t\t}\n\t}, [\n\t\turlParams.params,\n\t\tgraph,\n\t\tcurrentPage,\n\t\tallState,\n\t\tonPageChange,\n\t\tpageParamName,\n\t\turlParams,\n\t\tstateManager,\n\t\tflowUuid,\n\t\tisValidating,\n\t\tenableState,\n\t]);\n\n\t// Check if current page should be skipped and navigate if needed\n\t// This runs when a page loads to handle conditional skipping\n\tuseEffect(() => {\n\t\t// Reset skip check ref when page changes\n\t\tskipCheckRef.current = false;\n\n\t\tif (!currentPage) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if current page should be skipped\n\t\tif (shouldSkipStep(graph, currentPage, allState)) {\n\t\t\tsetIsCheckingSkip(true);\n\t\t\tskipCheckRef.current = true;\n\n\t\t\t// Find next non-skipped page\n\t\t\tconst nextPage = getNextPage(graph, currentPage, allState);\n\n\t\t\tif (nextPage) {\n\t\t\t\t// Replace URL (don't add to history) since we're skipping\n\t\t\t\turlParams.replaceParam(pageParamName, nextPage);\n\t\t\t\tsetCurrentPage(nextPage);\n\t\t\t\tonPageChange?.(nextPage, currentPage, allState);\n\t\t\t}\n\n\t\t\tsetIsCheckingSkip(false);\n\t\t}\n\t}, [currentPage, graph, allState, pageParamName, urlParams, onPageChange]);\n\n\t// Navigation functions\n\tconst goToNext = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextPage = getNextPage(graph, currentPage, allState);\n\t\tif (!nextPage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst previousPage = currentPage;\n\n\t\t// Check if we're skipping any steps\n\t\t// If the next page is different from what would be the direct next,\n\t\t// we're skipping steps\n\t\tconst currentNode = getNode(graph, currentPage);\n\t\tconst directNext = currentNode\n\t\t\t? resolveNextPage(currentNode, allState)\n\t\t\t: null;\n\n\t\t// If nextPage is different from directNext, we skipped steps\n\t\tconst isSkipping = directNext !== null && directNext !== nextPage;\n\n\t\t// Use replaceParam if skipping (to remove skipped steps from history)\n\t\t// Otherwise use setParam (normal navigation adds to history)\n\t\tif (isSkipping) {\n\t\t\t// When skipping, replace current entry to avoid skipped pages in history\n\t\t\turlParams.replaceParam(pageParamName, nextPage);\n\t\t} else {\n\t\t\t// Normal navigation - add to history\n\t\t\turlParams.setParam(pageParamName, nextPage);\n\t\t}\n\n\t\tsetCurrentPage(nextPage);\n\t\tonPageChange?.(nextPage, previousPage, allState);\n\t}, [graph, currentPage, allState, onPageChange, pageParamName, urlParams]);\n\n\tconst goToPrevious = useCallback(() => {\n\t\t// Use browser history back - the history is already correct because skipped pages\n\t\t// are replaced with replaceParam, so history.back() will go to the correct previous page\n\t\tif (typeof window !== \"undefined\" && window.history.length > 1) {\n\t\t\twindow.history.back();\n\t\t}\n\t}, []);\n\n\tconst goToPage = useCallback(\n\t\t(page: string) => {\n\t\t\tif (!graph.nodes.has(page)) {\n\t\t\t\tconsole.warn(`Page \"${page}\" does not exist in graph`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst previousPage = currentPage;\n\n\t\t\tsetCurrentPage(page);\n\t\t\turlParams.setParam(pageParamName, page);\n\t\t\tonPageChange?.(page, previousPage, allState);\n\t\t},\n\t\t[graph, currentPage, allState, onPageChange, pageParamName, urlParams],\n\t);\n\n\tconst skipToPage = useCallback(\n\t\t(page: string) => {\n\t\t\tif (!graph.nodes.has(page)) {\n\t\t\t\tconsole.warn(`Page \"${page}\" does not exist in graph`);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst previousPage = currentPage;\n\n\t\t\tsetCurrentPage(page);\n\t\t\turlParams.replaceParam(pageParamName, page);\n\t\t\tonPageChange?.(page, previousPage, allState);\n\t\t},\n\t\t[graph, currentPage, allState, onPageChange, pageParamName, urlParams],\n\t);\n\n\t// Skip current page and navigate to next non-skipped page\n\t// This can be called from within a page component after loading\n\tconst skipCurrentPage = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn;\n\t\t}\n\n\t\tsetIsCheckingSkip(true);\n\t\tskipCheckRef.current = true;\n\n\t\t// Find next non-skipped page\n\t\tconst nextPage = getNextPage(graph, currentPage, allState);\n\n\t\tif (nextPage) {\n\t\t\t// Replace URL (don't add to history) since we're skipping\n\t\t\t// This ensures skipped pages don't appear in browser history\n\t\t\turlParams.replaceParam(pageParamName, nextPage);\n\t\t\tsetCurrentPage(nextPage);\n\t\t\tonPageChange?.(nextPage, currentPage, allState);\n\t\t}\n\n\t\tsetIsCheckingSkip(false);\n\t}, [currentPage, graph, allState, pageParamName, urlParams, onPageChange]);\n\n\t// Complete flow and clear state (session storage when enabled, in-memory when disabled)\n\t// User is responsible for handling navigation/redirect after calling this\n\tconst completeFlow = useCallback(() => {\n\t\tif (enableState) {\n\t\t\tstateManager.clearState(flowUuid);\n\t\t} else {\n\t\t\tsetMemoryEntries([]);\n\t\t}\n\t}, [enableState, stateManager, flowUuid]);\n\n\t// State update functions\n\tconst updateState = useCallback(\n\t\t(key: string, value: unknown) => {\n\t\t\tif (!currentPage) return;\n\t\t\tif (enableState) {\n\t\t\t\tstateManager.setState(flowUuid, currentPage, key, value);\n\t\t\t\tsetStateVersion((prev) => prev + 1);\n\t\t\t} else {\n\t\t\t\tsetMemoryEntries((prev) => {\n\t\t\t\t\tconst next = [...prev];\n\t\t\t\t\tconst i = next.findIndex((e) => e.page === currentPage);\n\t\t\t\t\tconst entry =\n\t\t\t\t\t\ti >= 0 ? { ...next[i] } : { page: currentPage, state: {} };\n\t\t\t\t\tentry.state = { ...entry.state, [key]: value };\n\t\t\t\t\tif (i >= 0) next[i] = entry;\n\t\t\t\t\telse next.push(entry);\n\t\t\t\t\treturn next;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t[currentPage, enableState, stateManager, flowUuid],\n\t);\n\n\tconst updateStateBatch = useCallback(\n\t\t(updates: Record<string, unknown>) => {\n\t\t\tif (!currentPage) return;\n\t\t\tif (enableState) {\n\t\t\t\tstateManager.setStateBatch(flowUuid, currentPage, updates);\n\t\t\t\tsetStateVersion((prev) => prev + 1);\n\t\t\t} else {\n\t\t\t\tsetMemoryEntries((prev) => {\n\t\t\t\t\tconst next = [...prev];\n\t\t\t\t\tconst i = next.findIndex((e) => e.page === currentPage);\n\t\t\t\t\tconst entry =\n\t\t\t\t\t\ti >= 0 ? { ...next[i] } : { page: currentPage, state: {} };\n\t\t\t\t\tentry.state = { ...entry.state, ...updates };\n\t\t\t\t\tif (i >= 0) next[i] = entry;\n\t\t\t\t\telse next.push(entry);\n\t\t\t\t\treturn next;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t[currentPage, enableState, stateManager, flowUuid],\n\t);\n\n\tconst getPageState = useCallback(\n\t\t(page: string) => {\n\t\t\tif (enableState) {\n\t\t\t\treturn stateManager.getState(flowUuid, page);\n\t\t\t}\n\t\t\tconst entry = memoryEntries.find((e) => e.page === page);\n\t\t\treturn entry?.state ?? {};\n\t\t},\n\t\t[enableState, stateManager, flowUuid, memoryEntries],\n\t);\n\n\t// Helper functions\n\tconst getCurrentNode = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn getNode(graph, currentPage);\n\t}, [graph, currentPage]);\n\n\tconst getNodeByPage = useCallback(\n\t\t(page: string) => {\n\t\t\treturn getNode(graph, page);\n\t\t},\n\t\t[graph],\n\t);\n\n\tconst hasNext = useCallback(() => {\n\t\tif (!currentPage) {\n\t\t\treturn false;\n\t\t}\n\t\treturn getNextPage(graph, currentPage, allState) !== null;\n\t}, [graph, currentPage, allState]);\n\n\t// Build context value\n\tconst contextValue: FlowContextValue = useMemo(\n\t\t() => ({\n\t\t\tcurrentPage,\n\t\t\tstate: allState,\n\t\t\tgoToNext,\n\t\t\tgoToPrevious,\n\t\t\tgoToPage,\n\t\t\tskipToPage,\n\t\t\tupdateState,\n\t\t\tupdateStateBatch,\n\t\t\tgetPageState,\n\t\t\tgetCurrentNode,\n\t\t\tgetNode: getNodeByPage,\n\t\t\thasNext,\n\t\t\tskipCurrentPage,\n\t\t\tcompleteFlow,\n\t\t\tgetUrlParam: urlParams.getParam,\n\t\t\tgetAllUrlParams: urlParams.getAllParams,\n\t\t\turlParams: urlParams.params,\n\t\t}),\n\t\t[\n\t\t\tcurrentPage,\n\t\t\tallState,\n\t\t\tgoToNext,\n\t\t\tgoToPrevious,\n\t\t\tgoToPage,\n\t\t\tskipToPage,\n\t\t\tupdateState,\n\t\t\tupdateStateBatch,\n\t\t\tgetPageState,\n\t\t\tgetCurrentNode,\n\t\t\tgetNodeByPage,\n\t\t\thasNext,\n\t\t\tskipCurrentPage,\n\t\t\tcompleteFlow,\n\t\t\turlParams,\n\t\t],\n\t);\n\n\tconst currentNode = getCurrentNode();\n\n\t// Don't render anything while validating initial state (entry point + session storage check)\n\t// This prevents flicker when navigating to a non-entry-point page without state\n\tif (isValidating) {\n\t\treturn null;\n\t}\n\n\tif (isCheckingSkip) {\n\t\treturn (\n\t\t\t<FlowContext.Provider value={contextValue}>\n\t\t\t\t<div />\n\t\t\t</FlowContext.Provider>\n\t\t);\n\t}\n\n\treturn (\n\t\t<FlowContext.Provider value={contextValue}>\n\t\t\t<Presenter\n\t\t\t\tpage={currentPage}\n\t\t\t\tnode={currentNode}\n\t\t\t\tcomponentLoaders={componentLoadersMap}\n\t\t\t/>\n\t\t</FlowContext.Provider>\n\t);\n}\n","\"use client\";\n\nimport { createContext, useContext } from \"react\";\nimport type { FlowContextValue } from \"@/flow/types\";\n\n/**\n * React context for flow state and navigation\n */\nexport const FlowContext = createContext<FlowContextValue | null>(null);\n\n/**\n * Hook to access flow context\n * Throws an error if used outside of Flow component\n */\nexport function useFlowContext(): FlowContextValue {\n\tconst context = useContext(FlowContext);\n\tif (!context) {\n\t\tthrow new Error(\"useFlowContext must be used within a Flow component\");\n\t}\n\treturn context;\n}\n","import type { FlowGraph, FlowNode, FlowStateByPage } from \"@/flow/types\";\n\n/**\n * Creates a new empty flow graph\n */\nexport function createFlowGraph(): FlowGraph {\n\treturn {\n\t\tnodes: new Map<string, FlowNode>(),\n\t};\n}\n\n/**\n * Registers a node in the flow graph\n */\nexport function registerNode(graph: FlowGraph, node: FlowNode): void {\n\tif (graph.nodes.has(node.currentPage)) {\n\t\tthrow new Error(\n\t\t\t`Node with currentPage \"${node.currentPage}\" already exists in graph`,\n\t\t);\n\t}\n\n\tgraph.nodes.set(node.currentPage, node);\n\n\t// Set as entry point if it's the first node\n\tif (!graph.entryPoint) {\n\t\tgraph.entryPoint = node.currentPage;\n\t}\n}\n\n/**\n * Initialize a flow from an array of nodes.\n * Convenience for defining complete flows in one place.\n */\nexport function initializeFlow(\n\tnodes: FlowNode[],\n\tentryPoint?: string,\n): FlowGraph {\n\tconst graph = createFlowGraph();\n\n\tfor (const node of nodes) {\n\t\tregisterNode(graph, node);\n\t}\n\n\t// Override entry point if explicitly provided\n\tif (entryPoint) {\n\t\tif (!graph.nodes.has(entryPoint)) {\n\t\t\tthrow new Error(`Entry point \"${entryPoint}\" does not exist in nodes`);\n\t\t}\n\t\tgraph.entryPoint = entryPoint;\n\t}\n\n\treturn graph;\n}\n\n/**\n * Gets a node by its page identifier\n */\nexport function getNode(graph: FlowGraph, page: string): FlowNode | undefined {\n\treturn graph.nodes.get(page);\n}\n\n/**\n * Checks if a step should be skipped based on its shouldSkip function and current state\n */\nexport function shouldSkipStep(\n\tgraph: FlowGraph,\n\tpage: string,\n\tstate: FlowStateByPage,\n): boolean {\n\tconst node = getNode(graph, page);\n\tif (!node) {\n\t\treturn false;\n\t}\n\n\tif (node.shouldSkip) {\n\t\treturn node.shouldSkip(state);\n\t}\n\n\treturn false;\n}\n\n/**\n * Resolves the next page for a given node based on current state\n */\nexport function resolveNextPage(\n\tnode: FlowNode,\n\tstate: FlowStateByPage,\n): string | null {\n\tif (!node.nextPage) {\n\t\treturn null;\n\t}\n\n\t// If it's a function, evaluate it with current state\n\tif (typeof node.nextPage === \"function\") {\n\t\treturn node.nextPage(state);\n\t}\n\n\t// Otherwise, return the string directly\n\treturn node.nextPage;\n}\n\n/**\n * Recursively finds the next non-skipped page, preventing infinite loops\n */\nexport function getNextNonSkippedPage(\n\tgraph: FlowGraph,\n\tpage: string,\n\tstate: FlowStateByPage,\n\tvisited: Set<string> = new Set(),\n): string | null {\n\t// Prevent infinite loops\n\tif (visited.has(page)) {\n\t\tconsole.warn(`Circular skip condition detected for page \"${page}\"`);\n\t\treturn null;\n\t}\n\tvisited.add(page);\n\n\t// Check if current page should be skipped\n\tif (shouldSkipStep(graph, page, state)) {\n\t\tconst node = getNode(graph, page);\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst nextPage = resolveNextPage(node, state);\n\t\tif (!nextPage || !graph.nodes.has(nextPage)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Recursively check the next page\n\t\treturn getNextNonSkippedPage(graph, nextPage, state, visited);\n\t}\n\n\t// Page should not be skipped, return it\n\treturn page;\n}\n\n/**\n * Gets the next page for navigation (returns first page if multiple)\n * Automatically skips steps that should be skipped\n */\nexport function getNextPage(\n\tgraph: FlowGraph,\n\tcurrentPage: string,\n\tstate: FlowStateByPage,\n): string | null {\n\tconst currentNode = getNode(graph, currentPage);\n\tif (!currentNode) {\n\t\treturn null;\n\t}\n\n\tconst nextPage = resolveNextPage(currentNode, state);\n\n\tif (!nextPage) {\n\t\treturn null;\n\t}\n\n\t// Validate that the next page exists in the graph\n\tif (!graph.nodes.has(nextPage)) {\n\t\tconsole.warn(`Next page \"${nextPage}\" does not exist in graph`);\n\t\treturn null;\n\t}\n\n\t// Check if the next page should be skipped and find the first non-skipped page\n\treturn getNextNonSkippedPage(graph, nextPage, state);\n}\n\n/**\n * Gets the next page (returns as array for consistency with previous API)\n * @deprecated Consider using getNextPage instead\n */\nexport function getAllNextPages(\n\tgraph: FlowGraph,\n\tcurrentPage: string,\n\tstate: FlowStateByPage,\n): string[] {\n\tconst nextPage = getNextPage(graph, currentPage, state);\n\treturn nextPage ? [nextPage] : [];\n}\n\n/**\n * Recursively finds the previous non-skipped page, preventing infinite loops\n */\nexport function getPreviousNonSkippedPage(\n\tgraph: FlowGraph,\n\tpage: string,\n\tstate: FlowStateByPage,\n\tvisited: Set<string> = new Set(),\n): string | null {\n\t// Prevent infinite loops\n\tif (visited.has(page)) {\n\t\tconsole.warn(`Circular skip condition detected for page \"${page}\"`);\n\t\treturn null;\n\t}\n\tvisited.add(page);\n\n\tconst node = getNode(graph, page);\n\tif (!node) {\n\t\treturn null;\n\t}\n\n\tif (!node.previousPageFallback) {\n\t\treturn null;\n\t}\n\n\t// Validate that the previous page exists\n\tif (!graph.nodes.has(node.previousPageFallback)) {\n\t\tconsole.warn(\n\t\t\t`Previous page \"${node.previousPageFallback}\" does not exist in graph`,\n\t\t);\n\t\treturn null;\n\t}\n\n\t// Check if previous page should be skipped\n\tif (shouldSkipStep(graph, node.previousPageFallback, state)) {\n\t\t// Recursively check the previous page\n\t\treturn getPreviousNonSkippedPage(\n\t\t\tgraph,\n\t\t\tnode.previousPageFallback,\n\t\t\tstate,\n\t\t\tvisited,\n\t\t);\n\t}\n\n\t// Previous page should not be skipped, return it\n\treturn node.previousPageFallback;\n}\n\n/**\n * Gets the previous page for a given node\n * Automatically skips over steps that should be skipped\n */\nexport function getPreviousPage(\n\tgraph: FlowGraph,\n\tcurrentPage: string,\n\tstate: FlowStateByPage,\n): string | null {\n\tconst currentNode = getNode(graph, currentPage);\n\tif (!currentNode) {\n\t\treturn null;\n\t}\n\n\tif (!currentNode.previousPageFallback) {\n\t\treturn null;\n\t}\n\n\t// Validate that the previous page exists\n\tif (!graph.nodes.has(currentNode.previousPageFallback)) {\n\t\tconsole.warn(\n\t\t\t`Previous page \"${currentNode.previousPageFallback}\" does not exist in graph`,\n\t\t);\n\t\treturn null;\n\t}\n\n\t// Check if previous page should be skipped and find the first non-skipped page\n\treturn getPreviousNonSkippedPage(graph, currentPage, state);\n}\n\n/**\n * Validates that all referenced pages in the graph exist\n */\nexport function validateGraph(graph: FlowGraph): {\n\tvalid: boolean;\n\terrors: string[];\n} {\n\tconst errors: string[] = [];\n\n\t// Check that entry point exists\n\tif (graph.entryPoint && !graph.nodes.has(graph.entryPoint)) {\n\t\terrors.push(`Entry point \"${graph.entryPoint}\" does not exist in graph`);\n\t}\n\n\t// Validate all node references\n\tfor (const [page, node] of graph.nodes.entries()) {\n\t\t// Check previousPageFallback reference\n\t\tif (\n\t\t\tnode.previousPageFallback &&\n\t\t\t!graph.nodes.has(node.previousPageFallback)\n\t\t) {\n\t\t\terrors.push(\n\t\t\t\t`Node \"${page}\" references non-existent previous page \"${node.previousPageFallback}\"`,\n\t\t\t);\n\t\t}\n\n\t\t// Check nextPage reference (for string case)\n\t\tif (node.nextPage && typeof node.nextPage !== \"function\") {\n\t\t\tif (!graph.nodes.has(node.nextPage)) {\n\t\t\t\terrors.push(\n\t\t\t\t\t`Node \"${page}\" references non-existent next page \"${node.nextPage}\"`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tvalid: errors.length === 0,\n\t\terrors,\n\t};\n}\n\n/**\n * Gets all pages in the graph in topological order (if possible)\n * Falls back to registration order if cycles exist\n */\nexport function getPagesInOrder(graph: FlowGraph): string[] {\n\tconst visited = new Set<string>();\n\tconst result: string[] = [];\n\n\tfunction visit(page: string) {\n\t\tif (visited.has(page)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvisited.add(page);\n\t\tconst node = graph.nodes.get(page);\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Visit previous first (if exists)\n\t\tif (node.previousPageFallback) {\n\t\t\tvisit(node.previousPageFallback);\n\t\t}\n\n\t\tresult.push(page);\n\n\t\t// Visit next page\n\t\tif (node.nextPage && typeof node.nextPage !== \"function\") {\n\t\t\tvisit(node.nextPage);\n\t\t}\n\t}\n\n\t// Start from entry point or all nodes\n\tif (graph.entryPoint) {\n\t\tvisit(graph.entryPoint);\n\t}\n\n\t// Visit any remaining unvisited nodes\n\tfor (const page of graph.nodes.keys()) {\n\t\tif (!visited.has(page)) {\n\t\t\tvisit(page);\n\t\t}\n\t}\n\n\treturn result;\n}\n","import { getPagesInOrder } from \"@/flow/graphHelpers\";\nimport type { FlowGraph, FlowState, FlowStateByPage } from \"@/flow/types\";\n\n/**\n * Session storage key prefix for flow state\n */\nconst STORAGE_PREFIX = \"flow:\";\n\n/**\n * Structure for storing page state in session storage\n */\ntype PageStateEntry = {\n\tpage: string;\n\tstate: FlowState;\n};\n\n/**\n * Manager for wizard state stored in session storage\n * Uses UUID-based storage with array structure: wizard:{uuid}: [{ page, state }, ...]\n */\nexport class WizardStateManager {\n\tprivate prefix: string;\n\n\tconstructor(prefix: string = STORAGE_PREFIX) {\n\t\tthis.prefix = prefix;\n\t}\n\n\t/**\n\t * Gets the storage key for a wizard UUID\n\t */\n\tprivate getStorageKey(uuid: string): string {\n\t\treturn `${this.prefix}${uuid}`;\n\t}\n\n\t/**\n\t * Gets all page state entries for a wizard UUID\n\t */\n\tprivate getPageStateEntries(uuid: string): PageStateEntry[] {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst storageKey = this.getStorageKey(uuid);\n\t\tconst stored = window.sessionStorage.getItem(storageKey);\n\n\t\tif (!stored) {\n\t\t\treturn [];\n\t\t}\n\n\t\ttry {\n\t\t\treturn JSON.parse(stored) as PageStateEntry[];\n\t\t} catch (error) {\n\t\t\tconsole.warn(`Failed to parse state for UUID \"${uuid}\":`, error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Saves all page state entries for a wizard UUID\n\t */\n\tprivate setPageStateEntries(uuid: string, entries: PageStateEntry[]): void {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst storageKey = this.getStorageKey(uuid);\n\t\ttry {\n\t\t\twindow.sessionStorage.setItem(storageKey, JSON.stringify(entries));\n\t\t} catch (error) {\n\t\t\tconsole.error(`Failed to save state for UUID \"${uuid}\":`, error);\n\t\t}\n\t}\n\n\t/**\n\t * Pre-registers all expected state keys from the graph\n\t * This allows us to see all expected state upfront\n\t */\n\tpreRegisterState(graph: FlowGraph, uuid: string): void {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tconst pages = getPagesInOrder(graph);\n\t\tconst existingPages = new Set(entries.map((e) => e.page));\n\n\t\t// Initialize entries for pages that don't exist yet\n\t\tfor (const page of pages) {\n\t\t\tif (!existingPages.has(page)) {\n\t\t\t\tentries.push({ page, state: {} });\n\t\t\t}\n\t\t}\n\n\t\t// Save the updated entries\n\t\tthis.setPageStateEntries(uuid, entries);\n\t}\n\n\t/**\n\t * Gets state for a specific page\n\t */\n\tgetState(uuid: string, page: string): FlowState {\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tconst entry = entries.find((e) => e.page === page);\n\t\treturn entry?.state || {};\n\t}\n\n\t/**\n\t * Sets state for a specific page\n\t */\n\tsetState(uuid: string, page: string, key: string, value: unknown): void {\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tlet entry = entries.find((e) => e.page === page);\n\n\t\tif (!entry) {\n\t\t\tentry = { page, state: {} };\n\t\t\tentries.push(entry);\n\t\t}\n\n\t\tentry.state[key] = value;\n\t\tthis.setPageStateEntries(uuid, entries);\n\t}\n\n\t/**\n\t * Sets multiple state values for a page at once\n\t */\n\tsetStateBatch(\n\t\tuuid: string,\n\t\tpage: string,\n\t\tupdates: Record<string, unknown>,\n\t): void {\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tlet entry = entries.find((e) => e.page === page);\n\n\t\tif (!entry) {\n\t\t\tentry = { page, state: {} };\n\t\t\tentries.push(entry);\n\t\t}\n\n\t\tObject.assign(entry.state, updates);\n\t\tthis.setPageStateEntries(uuid, entries);\n\t}\n\n\t/**\n\t * Gets accumulated state from all pages, keyed by page.\n\t * Each page has its own namespace so the same key (e.g. \"name\") won't overwrite.\n\t */\n\tgetAllState(_graph: FlowGraph, uuid: string): FlowStateByPage {\n\t\tconst byPage: FlowStateByPage = {};\n\t\tconst entries = this.getPageStateEntries(uuid);\n\n\t\tfor (const entry of entries) {\n\t\t\tbyPage[entry.page] = { ...entry.state };\n\t\t}\n\n\t\treturn byPage;\n\t}\n\n\t/**\n\t * Gets state for all pages up to and including the specified page, keyed by page\n\t */\n\tgetStateUpTo(_graph: FlowGraph, uuid: string, page: string): FlowStateByPage {\n\t\tconst byPage: FlowStateByPage = {};\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tconst pages = getPagesInOrder(_graph);\n\n\t\tfor (const p of pages) {\n\t\t\tconst entry = entries.find((e) => e.page === p);\n\t\t\tif (entry) {\n\t\t\t\tbyPage[p] = { ...entry.state };\n\t\t\t}\n\t\t\tif (p === page) break;\n\t\t}\n\n\t\treturn byPage;\n\t}\n\n\t/**\n\t * Checks if state exists for a specific UUID\n\t */\n\thasState(uuid: string): boolean {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst storageKey = this.getStorageKey(uuid);\n\t\tconst stored = window.sessionStorage.getItem(storageKey);\n\t\treturn stored !== null && stored !== \"\";\n\t}\n\n\t/**\n\t * Clears all wizard state for a specific UUID\n\t */\n\tclearState(uuid: string): void {\n\t\tif (typeof window === \"undefined\" || !window.sessionStorage) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst storageKey = this.getStorageKey(uuid);\n\t\twindow.sessionStorage.removeItem(storageKey);\n\t}\n\n\t/**\n\t * Clears state for a specific page within a wizard UUID\n\t */\n\tclearPageState(uuid: string, page: string): void {\n\t\tconst entries = this.getPageStateEntries(uuid);\n\t\tconst filtered = entries.filter((e) => e.page !== page);\n\t\tthis.setPageStateEntries(uuid, filtered);\n\t}\n}\n\n/**\n * Default instance of WizardStateManager\n */\nexport const defaultStateManager = new WizardStateManager();\n","import { lazy, Suspense, useMemo } from \"react\";\nimport type { ComponentLoader, FlowNode } from \"@/flow/types\";\n\n/**\n * Props for the Presenter component\n */\nexport type PresenterProps = {\n\t/**\n\t * Current page identifier\n\t */\n\tpage: string | null;\n\n\t/**\n\t * Current node definition\n\t */\n\tnode: FlowNode | undefined;\n\n\t/**\n\t * Map of page identifiers to component loaders\n\t * Each loader should return a promise that resolves to a component with a default export\n\t */\n\tcomponentLoaders: Map<string, ComponentLoader>;\n};\n\n/**\n * Presenter component that dynamically loads and renders flow pages\n * Uses React.lazy for code splitting and tree shaking\n * Dynamically loads components based on the provided componentLoaders map\n * Components should handle their own loading states\n */\nexport function Presenter({ page, node, componentLoaders }: PresenterProps) {\n\t// Memoize the lazy-loaded component to prevent remounting on every render\n\tconst Component = useMemo(() => {\n\t\tif (!page) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst loader = componentLoaders.get(page);\n\t\tif (!loader) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Use React.lazy to wrap the loader function\n\t\treturn lazy(loader);\n\t}, [page, componentLoaders]);\n\n\t// Handle special states (expired, not found) - don't require a node for these cases\n\tif (page === \"__expired__\" || page === \"__notfound__\") {\n\t\tif (!Component) {\n\t\t\tconsole.warn(\n\t\t\t\t`No component loader found for page \"${page}\". Add it to your componentLoaders map.`,\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\t\treturn (\n\t\t\t<Suspense fallback={null}>\n\t\t\t\t<Component />\n\t\t\t</Suspense>\n\t\t);\n\t}\n\n\tif (!page || !node) {\n\t\treturn null;\n\t}\n\n\tif (!Component) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<Suspense fallback={null}>\n\t\t\t<Component />\n\t\t</Suspense>\n\t);\n}\n","import { useCallback, useEffect, useState } from \"react\";\nimport type { UrlParamsAdapter } from \"@/flow/types\";\n\n/**\n * Default browser-based URL params adapter\n */\nexport const browserUrlParamsAdapter: UrlParamsAdapter = {\n\tgetParam: (key: string): string | null => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn null;\n\t\t}\n\t\tconst params = new URLSearchParams(window.location.search);\n\t\treturn params.get(key);\n\t},\n\n\tsetParam: (key: string, value: string): void => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\t\tconst url = new URL(window.location.href);\n\t\turl.searchParams.set(key, value);\n\t\twindow.history.pushState({}, \"\", url.toString());\n\t},\n\n\treplaceParam: (key: string, value: string): void => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\t\tconst url = new URL(window.location.href);\n\t\turl.searchParams.set(key, value);\n\t\twindow.history.replaceState({}, \"\", url.toString());\n\t},\n\n\tgetAllParams: (): Record<string, string> => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn {};\n\t\t}\n\t\tconst params = new URLSearchParams(window.location.search);\n\t\tconst result: Record<string, string> = {};\n\t\tfor (const [key, value] of params.entries()) {\n\t\t\tresult[key] = value;\n\t\t}\n\t\treturn result;\n\t},\n\n\treplaceParams: (params: Record<string, string>): void => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\t\tconst url = new URL(window.location.href);\n\t\t// Clear existing params\n\t\turl.search = \"\";\n\t\t// Set new params\n\t\tfor (const [key, value] of Object.entries(params)) {\n\t\t\turl.searchParams.set(key, value);\n\t\t}\n\t\twindow.history.replaceState({}, \"\", url.toString());\n\t},\n};\n\n/**\n * Hook for managing URL parameters in a framework-agnostic way\n */\nexport function useUrlParams(\n\tadapter: UrlParamsAdapter = browserUrlParamsAdapter,\n) {\n\tconst [params, setParams] = useState<Record<string, string>>(() =>\n\t\tadapter.getAllParams(),\n\t);\n\n\t// Sync with URL changes (browser back/forward) and when adapter changes\n\tuseEffect(() => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn;\n\t\t}\n\n\t\t// Re-read from current URL when adapter changes (e.g. after popstate + parent re-render)\n\t\tsetParams(adapter.getAllParams());\n\n\t\tconst handlePopState = () => {\n\t\t\tsetParams(adapter.getAllParams());\n\t\t};\n\n\t\twindow.addEventListener(\"popstate\", handlePopState);\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"popstate\", handlePopState);\n\t\t};\n\t}, [adapter]);\n\n\tconst getParam = useCallback(\n\t\t(key: string): string | null => {\n\t\t\treturn adapter.getParam(key);\n\t\t},\n\t\t[adapter],\n\t);\n\n\tconst setParam = useCallback(\n\t\t(key: string, value: string): void => {\n\t\t\tadapter.setParam(key, value);\n\t\t\tsetParams(adapter.getAllParams());\n\t\t},\n\t\t[adapter],\n\t);\n\n\tconst replaceParam = useCallback(\n\t\t(key: string, value: string): void => {\n\t\t\tadapter.replaceParam(key, value);\n\t\t\tsetParams(adapter.getAllParams());\n\t\t},\n\t\t[adapter],\n\t);\n\n\tconst getAllParams = useCallback((): Record<string, string> => {\n\t\treturn adapter.getAllParams();\n\t}, [adapter]);\n\n\tconst replaceParams = useCallback(\n\t\t(newParams: Record<string, string>): void => {\n\t\t\tadapter.replaceParams(newParams);\n\t\t\tsetParams(adapter.getAllParams());\n\t\t},\n\t\t[adapter],\n\t);\n\n\treturn {\n\t\tgetParam,\n\t\tsetParam,\n\t\treplaceParam,\n\t\tgetAllParams,\n\t\treplaceParams,\n\t\tparams,\n\t};\n}\n","import type { UrlParamsAdapter } from \"@/flow/types\";\n\n/**\n * Configuration for path-based URL parameters\n * Defines the structure of the URL path with named segments\n *\n * Example: \"/[id]/page/[page]\" would match \"/abc123/page/pageA\"\n * and extract { id: \"abc123\", page: \"pageA\" }\n */\nexport type PathConfig = {\n\t/**\n\t * Path template with named segments in brackets\n\t * Example: \"/[id]/page/[page]\" or \"/wizard/[id]/[page]\"\n\t */\n\ttemplate: string;\n\n\t/**\n\t * Base path to prepend to the template (optional)\n\t * Example: \"/wizard\" would make the full path \"/wizard/[id]/page/[page]\"\n\t */\n\tbasePath?: string;\n};\n\n/**\n * Parses a path template and extracts parameter names\n * Example: \"/[id]/page/[page]\" -> [\"id\", \"page\"]\n */\nfunction parsePathTemplate(template: string): string[] {\n\tconst matches = template.match(/\\[([^\\]]+)\\]/g);\n\tif (!matches) {\n\t\treturn [];\n\t}\n\treturn matches.map((match) => match.slice(1, -1));\n}\n\n/**\n * Builds a path from a template and parameter values\n * Example: template=\"/[id]/page/[page]\", params={id: \"abc\", page: \"pageA\"}\n * Result: \"/abc/page/pageA\"\n */\nfunction buildPath(template: string, params: Record<string, string>): string {\n\tlet path = template;\n\tfor (const [key, value] of Object.entries(params)) {\n\t\tpath = path.replace(`[${key}]`, encodeURIComponent(value));\n\t}\n\treturn path;\n}\n\n/**\n * Parses a URL path and extracts parameter values based on a template\n * Example: path=\"/en/wizard/abc/pageA\", template=\"/wizard/[id]/[page]\"\n * Result: { id: \"abc\", page: \"pageA\" }\n */\nfunction parsePath(path: string, template: string): Record<string, string> {\n\tconst params: Record<string, string> = {};\n\tconst paramNames = parsePathTemplate(template);\n\n\tif (paramNames.length === 0) {\n\t\treturn params;\n\t}\n\n\t// Convert template to regex pattern\n\t// Allow optional leading segments (like /en) before the template\n\tconst pattern = template\n\t\t.replace(/\\[([^\\]]+)\\]/g, \"([^/]+)\") // Replace [param] with capture group\n\t\t.replace(/\\//g, \"\\\\/\"); // Escape slashes\n\n\t// Make the pattern match from the end or allow optional prefix\n\t// This handles cases like /en/wizard/[id]/[page] matching /en/wizard/abc/pageA\n\tconst regex = new RegExp(`${pattern}$`);\n\tconst matches = path.match(regex);\n\n\tif (matches) {\n\t\t// matches[0] is the full match, matches[1..] are the captured groups\n\t\tfor (let i = 0; i < paramNames.length; i++) {\n\t\t\tconst value = matches[i + 1];\n\t\t\tif (value) {\n\t\t\t\tparams[paramNames[i]] = decodeURIComponent(value);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn params;\n}\n\n/**\n * Creates a path-based URL params adapter\n * This adapter uses URL path segments instead of query parameters\n *\n * @param config - Path configuration defining the URL structure\n * @returns A UrlParamsAdapter that works with path segments\n *\n * @example\n * ```ts\n * const adapter = createPathParamsAdapter({\n *   template: \"/[id]/page/[page]\"\n * });\n * // URLs will be like: /abc123/page/pageA\n * ```\n */\nexport function createPathParamsAdapter(config: PathConfig): UrlParamsAdapter {\n\tconst fullTemplate = config.basePath\n\t\t? `${config.basePath}${config.template}`\n\t\t: config.template;\n\n\tconst paramNames = parsePathTemplate(fullTemplate);\n\n\tconst getCurrentPath = (): string => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn window.location.pathname;\n\t};\n\n\tconst getCurrentParams = (): Record<string, string> => {\n\t\tconst path = getCurrentPath();\n\t\treturn parsePath(path, fullTemplate);\n\t};\n\n\tconst buildFullPath = (params: Record<string, string>): string => {\n\t\t// Get current params and merge with new ones\n\t\tconst currentParams = getCurrentParams();\n\t\tconst mergedParams = { ...currentParams, ...params };\n\n\t\t// Ensure all required params are present\n\t\tfor (const paramName of paramNames) {\n\t\t\tif (!mergedParams[paramName]) {\n\t\t\t\t// Keep existing value if available\n\t\t\t\tconst currentValue = getCurrentParams()[paramName];\n\t\t\t\tif (currentValue) {\n\t\t\t\t\tmergedParams[paramName] = currentValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst newPath = buildPath(fullTemplate, mergedParams);\n\n\t\t// If the current path has segments before our template (like /en),\n\t\t// preserve them in the new path\n\t\tconst currentPath = getCurrentPath();\n\t\tconst templateStart = currentPath.indexOf(fullTemplate.split(\"[\")[0]);\n\t\tif (templateStart > 0) {\n\t\t\t// There's a prefix before our template, preserve it\n\t\t\tconst prefix = currentPath.slice(0, templateStart);\n\t\t\treturn prefix + newPath;\n\t\t}\n\n\t\treturn newPath;\n\t};\n\n\treturn {\n\t\tgetParam: (key: string): string | null => {\n\t\t\tconst params = getCurrentParams();\n\t\t\treturn params[key] || null;\n\t\t},\n\n\t\tsetParam: (key: string, value: string): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Only update if this param is in the template\n\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath({ [key]: value });\n\t\t\twindow.history.pushState({}, \"\", newPath);\n\t\t},\n\n\t\treplaceParam: (key: string, value: string): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Only update if this param is in the template\n\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath({ [key]: value });\n\t\t\twindow.history.replaceState({}, \"\", newPath);\n\t\t},\n\n\t\tgetAllParams: (): Record<string, string> => {\n\t\t\treturn getCurrentParams();\n\t\t},\n\n\t\treplaceParams: (params: Record<string, string>): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Validate all params are in template\n\t\t\tfor (const key of Object.keys(params)) {\n\t\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath(params);\n\t\t\twindow.history.replaceState({}, \"\", newPath);\n\t\t},\n\t};\n}\n\n/**\n * Framework-agnostic path params adapter that reads initial params from props\n * Works with any framework that provides route params (Next.js, Remix, etc.)\n * Uses browser History API for navigation, making it framework-agnostic\n *\n * @param pathParams - Route params from your framework (can be a Promise in Next.js 15+)\n * @param config - Path configuration\n * @returns A UrlParamsAdapter that works with path segments\n *\n * @example\n * ```tsx\n * // Next.js example\n * export default function FlowPage({ params }: { params: Promise<{ id: string; page: string }> }) {\n *   const resolvedParams = use(params);\n *   const adapter = createPathParamsAdapterFromProps(\n *     resolvedParams,\n *     { template: \"/[id]/[page]\", basePath: \"/flow\" }\n *   );\n *   return <Flow graph={graph} config={{ urlParamsAdapter: adapter }} />;\n * }\n *\n * // Other frameworks (Remix, etc.)\n * export default function FlowPage({ params }: { params: { id: string; page: string } }) {\n *   const adapter = createPathParamsAdapterFromProps(\n *     params,\n *     { template: \"/[id]/[page]\", basePath: \"/flow\" }\n *   );\n *   return <Flow graph={graph} config={{ urlParamsAdapter: adapter }} />;\n * }\n * ```\n */\nexport function createPathParamsAdapterFromProps(\n\t_pathParams:\n\t\t| Record<string, string | string[]>\n\t\t| Promise<Record<string, string | string[]>>,\n\tconfig: PathConfig,\n): UrlParamsAdapter {\n\tconst fullTemplate = config.basePath\n\t\t? `${config.basePath}${config.template}`\n\t\t: config.template;\n\n\tconst paramNames = parsePathTemplate(fullTemplate);\n\n\t// Read params from the URL path directly (framework-agnostic)\n\t// The URL is always the source of truth, even on initial render\n\tconst getCurrentPath = (): string => {\n\t\tif (typeof window === \"undefined\") {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn window.location.pathname;\n\t};\n\n\tconst getCurrentParamsFromUrl = (): Record<string, string> => {\n\t\tconst path = getCurrentPath();\n\t\treturn parsePath(path, fullTemplate);\n\t};\n\n\t// Always read from URL - the URL is the source of truth\n\tconst getParams = (): Record<string, string> => {\n\t\treturn getCurrentParamsFromUrl();\n\t};\n\n\tconst buildFullPath = (params: Record<string, string>): string => {\n\t\tconst current = getParams();\n\t\tconst mergedParams = { ...current, ...params };\n\t\treturn buildPath(fullTemplate, mergedParams);\n\t};\n\n\treturn {\n\t\tgetParam: (key: string): string | null => {\n\t\t\tconst params = getParams();\n\t\t\treturn params[key] || null;\n\t\t},\n\n\t\tsetParam: (key: string, value: string): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath({ [key]: value });\n\t\t\twindow.history.pushState({}, \"\", newPath);\n\t\t},\n\n\t\treplaceParam: (key: string, value: string): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath({ [key]: value });\n\t\t\twindow.history.replaceState({}, \"\", newPath);\n\t\t},\n\n\t\tgetAllParams: (): Record<string, string> => {\n\t\t\treturn { ...getParams() };\n\t\t},\n\n\t\treplaceParams: (params: Record<string, string>): void => {\n\t\t\tif (typeof window === \"undefined\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (const key of Object.keys(params)) {\n\t\t\t\tif (!paramNames.includes(key)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Parameter \"${key}\" is not defined in path template: ${fullTemplate}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst newPath = buildFullPath(params);\n\t\t\twindow.history.replaceState({}, \"\", newPath);\n\t\t},\n\t};\n}\n","\"use client\";\n\nimport { useCallback } from \"react\";\nimport { useFlowContext } from \"@/flow/FlowContext\";\nimport type { UseFlowReturn } from \"@/flow/types\";\n\n/**\n * Single hook to access all flow functionality.\n * Use one import and destructure what you need.\n *\n * stateKey is page-scoped: each page has its own namespace. Keys like \"name\" or \"email\"\n * won't collide across pages. For cross-page data (e.g. routing), use `state` or\n * `getPageState(page)`.\n *\n * @example\n * const { goToNext, goToPrevious, goToPage, skipToPage, stateKey, currentPage, hasNext } = useFlow();\n * const [name, setName] = stateKey(\"name\");  // Page-specific; no collision with other pages\n * // goToPage(page) — jump to any node, preserve history (push). skipToPage(page) — same, replace (no back).\n */\nexport function useFlow(): UseFlowReturn {\n\tconst ctx = useFlowContext();\n\n\tconst stateKey = useCallback(\n\t\t<T = unknown>(key: string) => {\n\t\t\tconst pageState = ctx.currentPage\n\t\t\t\t? ctx.getPageState(ctx.currentPage)\n\t\t\t\t: {};\n\t\t\tconst value = (pageState[key] as T | undefined) ?? undefined;\n\t\t\tconst setValue = (newValue: T) => ctx.updateState(key, newValue);\n\t\t\treturn [value, setValue] as const;\n\t\t},\n\t\t[ctx.currentPage, ctx.getPageState, ctx.updateState],\n\t);\n\n\treturn {\n\t\t...ctx,\n\t\tstateKey,\n\t\thasNext: ctx.hasNext(),\n\t};\n}\n"],"mappings":"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","names":["import_react","import_react","import_react","import_jsx_runtime","currentNode","import_react"]}